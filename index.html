<!DOCTYPE html>
<html>
<head>
    <title>K4 Full Functional Analyzer</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 2rem auto;
            padding: 20px;
            background: #f8f9fa;
        }
        .result {
            background: white;
            padding: 1rem;
            margin: 1rem 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        pre {
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <h2>Kryptos K4 Full Analysis</h2>
    <textarea id="input" rows="10" style="width: 100%">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPK</textarea>
    <button onclick="startFullAnalysis()">Start Analysis</button>
    <div id="output"></div>

<script>
class K4Analyzer {
    constructor() {
        this.ENG_FREQ = {
            'E': 12.70, 'T': 9.10, 'A': 8.20, 'O': 7.50, 'I': 6.90,
            'N': 6.70, 'S': 6.30, 'H': 6.10, 'R': 6.00, 'D': 4.30
        };
        this.TARGETS = ['BERLIN', 'CLOCK', 'SOUTH'];
    }

    // Полный метод Казиски
    kasiskiAnalysis(text) {
        const trigramMap = new Map();
        for (let i = 0; i < text.length - 2; i++) {
            const trigram = text.slice(i, i + 3);
            const positions = trigramMap.get(trigram) || [];
            positions.push(i);
            trigramMap.set(trigram, positions);
        }

        const distances = [];
        for (const [trigram, positions] of trigramMap) {
            if (positions.length > 1) {
                for (let i = 1; i < positions.length; i++) {
                    distances.push(positions[i] - positions[i - 1]);
                }
            }
        }

        const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
        return distances.reduce((a, b) => gcd(a, b), distances[0]) || 1;
    }

    // Полный тест Фридмана
    friedmanTest(text) {
        const freq = {};
        for (const c of text) freq[c] = (freq[c] || 0) + 1;
        const n = text.length;
        const sum = Object.values(freq).reduce((acc, val) => acc + val * (val - 1), 0);
        return sum / (n * (n - 1));
    }

    // Полный частотный анализ
    frequencyAnalysis(text) {
        const freq = {};
        for (const c of text) freq[c] = (freq[c] || 0) + 1;
        return Object.entries(freq)
            .sort((a, b) => b[1] - a[1])
            .map(([char, count]) => `${char}: ${count} (${(count/text.length*100).toFixed(2)}%)`);
    }

    // Генерация гипотез ключей
    generateKeys(text, keyLength) {
        const keys = [];
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        
        // Базовые ключи
        keys.push('BERLIN', 'CLOCK', 'NORTHEAST');
        
        // Генерация случайных ключей
        for (let i = 0; i < 20; i++) {
            let key = '';
            for (let j = 0; j < keyLength; j++) {
                key += chars[Math.floor(Math.random() * chars.length)];
            }
            keys.push(key);
        }
        return [...new Set(keys)];
    }

    // Полная дешифровка Виженера
    decrypt(text, key) {
        return [...text].map((c, i) => {
            const keyChar = key[i % key.length].toUpperCase();
            const shift = keyChar.charCodeAt(0) - 65;
            return String.fromCharCode(
                (c.toUpperCase().charCodeAt(0) - 65 - shift + 26) % 26 + 65
            );
        }).join('');
    }

    // Оценка результатов
    scoreDecryption(decrypted) {
        let score = 0;
        // Совпадение с частотностью
        const freq = this.frequencyAnalysis(decrypted);
        score += freq.reduce((acc, item) => {
            const char = item.split(':')[0];
            return acc + (this.ENG_FREQ[char] || 0);
        }, 0);
        
        // Наличие целевых слов
        score += this.TARGETS.reduce((acc, word) => 
            acc + (decrypted.includes(word) ? 100 : 0), 0);
            
        return score;
    }
}

function startFullAnalysis() {
    const input = document.getElementById('input').value.toUpperCase().replace(/[^A-Z]/g, '');
    const analyzer = new K4Analyzer();
    const output = document.getElementById('output');
    output.innerHTML = '';

    // 1. Анализ длины ключа
    const keyLength = analyzer.kasiskiAnalysis(input);
    output.innerHTML += `<div class="result"><h3>Key Length Analysis (Kasiski)</h3>Estimated key length: ${keyLength}</div>`;

    // 2. Тест Фридмана
    const friedmanIC = analyzer.friedmanTest(input);
    output.innerHTML += `<div class="result"><h3>Friedman Test</h3>Index of Coincidence: ${friedmanIC.toFixed(4)}</div>`;

    // 3. Частотный анализ
    const freqResults = analyzer.frequencyAnalysis(input);
    output.innerHTML += `<div class="result"><h3>Frequency Analysis</h3><pre>${freqResults.join('\n')}</pre></div>`;

    // 4. Дешифровка с ключами
    const keys = analyzer.generateKeys(input, keyLength);
    const results = keys.map(key => ({
        key,
        decrypted: analyzer.decrypt(input, key),
        score: analyzer.scoreDecryption(analyzer.decrypt(input, key))
    })).sort((a, b) => b.score - a.score);

    // 5. Вывод топ-10 результатов
    output.innerHTML += `<div class="result"><h3>Top 10 Results</h3>`;
    results.slice(0, 10).forEach((result, index) => {
        output.innerHTML += `
            <div style="margin: 15px 0; padding: 10px; background: #fff; border: 1px solid #eee;">
                <strong>#${index + 1}</strong> Key: ${result.key} (Score: ${result.score})<br>
                <pre>${result.decrypted.slice(0, 150)}...</pre>
                Matches: ${analyzer.TARGETS.filter(word => result.decrypted.includes(word)).join(', ')}
            </div>`;
    });
    output.innerHTML += `</div>`;
}
</script>
</body>
</html>
