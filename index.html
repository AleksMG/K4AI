<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° True ITN v18.0 ‚Äî K4 Cryptanalysis Professional</title>
    <style>
        :root {
            --bg: #0a0a14;
            --panel: #141428;
            --panel-hover: #1a1a30;
            --text: #f0f0f0;
            --text-dim: #b0b0c0;
            --primary: #00d4ff;
            --primary-glow: rgba(0, 212, 255, 0.3);
            --accent: #ff0066;
            --accent-glow: rgba(255, 0, 102, 0.3);
            --success: #00ff88;
            --success-glow: rgba(0, 255, 136, 0.3);
            --warning: #ffaa00;
            --k4: #ff7700;
            --k4-glow: rgba(255, 119, 0, 0.3);
            --phase: #aa88ff;
            --border: #2a2a40;
            --border-active: #404060;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', system-ui, sans-serif;
        }

        body {
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            line-height: 1.5;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        /* ==================== HEADER ==================== */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg, var(--panel), #1a1a35);
            border-radius: 16px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        h1 {
            color: var(--primary);
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 0 24px var(--primary-glow);
            letter-spacing: 1px;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .badge {
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .badge-k4 {
            background: linear-gradient(135deg, var(--k4), #ff4400);
            color: #fff;
            box-shadow: 0 0 16px var(--k4-glow);
        }

        .badge-neural {
            background: linear-gradient(135deg, var(--phase), #8866ff);
            color: #fff;
            box-shadow: 0 0 16px rgba(170, 136, 255, 0.3);
        }

        .badge-status {
            background: linear-gradient(135deg, var(--success), #00cc66);
            color: #000;
            box-shadow: 0 0 16px var(--success-glow);
        }

        /* ==================== GRID LAYOUT ==================== */
        .main-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* ==================== PANELS ==================== */
        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
        }

        .panel:hover {
            border-color: var(--border-active);
            transform: translateY(-2px);
        }

        .panel.k4 {
            border-color: var(--k4);
            box-shadow: 0 0 24px var(--k4-glow);
        }

        .panel-title {
            color: var(--primary);
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title.k4 {
            color: var(--k4);
            border-bottom-color: var(--k4);
        }

        /* ==================== INPUTS ==================== */
        .input-group {
            margin-bottom: 18px;
        }

        label {
            display: block;
            color: var(--primary);
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }

        label.k4 {
            color: var(--k4);
        }

        input, textarea, select {
            width: 100%;
            background: #0d0d1a;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 14px;
            border-radius: 10px;
            font-size: 0.95rem;
            font-family: 'Courier New', 'Consolas', monospace;
            transition: all 0.2s ease;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 16px var(--primary-glow);
        }

        textarea.k4-input:focus {
            border-color: var(--k4);
            box-shadow: 0 0 16px var(--k4-glow);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        /* ==================== BUTTONS ==================== */
        .controls {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 140px;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), #0099cc);
            color: #000;
            box-shadow: 0 4px 16px var(--primary-glow);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #33e0ff, #00aadd);
            box-shadow: 0 6px 24px var(--primary-glow);
        }

        .btn-k4 {
            background: linear-gradient(135deg, var(--k4), #ff5500);
            color: #fff;
            box-shadow: 0 4px 16px var(--k4-glow);
        }

        .btn-k4:hover {
            background: linear-gradient(135deg, #ff9944, #ff6622);
            box-shadow: 0 6px 24px var(--k4-glow);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #00cc66);
            color: #000;
            box-shadow: 0 4px 16px var(--success-glow);
        }

        .btn-copy {
            background: #1a1a30;
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-copy:hover {
            background: #252540;
            border-color: var(--primary);
        }

        /* ==================== OUTPUT BOXES ==================== */
        .output-box {
            background: #05050a;
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            min-height: 100px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 0.95rem;
            word-break: break-word;
            font-family: 'Courier New', 'Consolas', monospace;
            line-height: 1.6;
        }

        .output-box.k4 {
            border-color: var(--k4);
            color: var(--k4);
            box-shadow: inset 0 0 16px rgba(255, 119, 0, 0.1);
        }

        .output-box.success {
            border-color: var(--success);
            color: var(--success);
            box-shadow: inset 0 0 16px rgba(0, 255, 136, 0.1);
        }

        .highlighted-word {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
        }

        .highlighted-pair {
            background: rgba(255, 119, 0, 0.2);
            color: var(--k4);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
        }

        /* ==================== STATS GRID ==================== */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            padding: 16px;
            background: #0d0d1a;
            border-radius: 10px;
            margin-bottom: 16px;
        }

        .stat {
            text-align: center;
            padding: 12px;
            background: #0a0a14;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .stat-label {
            color: var(--text-dim);
            display: block;
            margin-bottom: 6px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            color: var(--primary);
            font-weight: 700;
            font-family: 'Courier New', 'Consolas', monospace;
            font-size: 1.1rem;
        }

        .stat-value.k4 {
            color: var(--k4);
        }

        .stat-value.success {
            color: var(--success);
        }

        .stat-value.warning {
            color: var(--warning);
        }

        /* ==================== PROGRESS BAR ==================== */
        .progress-container {
            margin: 16px 0;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #0d0d1a;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--k4), var(--primary), var(--success));
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        /* ==================== CONSCIOUSNESS GAUGE ==================== */
        .consciousness-container {
            margin: 20px 0;
            padding: 20px;
            background: #0d0d1a;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .consciousness-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .consciousness-title {
            color: var(--phase);
            font-weight: 700;
            font-size: 1rem;
        }

        .consciousness-value {
            color: var(--success);
            font-weight: 700;
            font-size: 1.5rem;
            font-family: 'Courier New', 'Consolas', monospace;
        }

        .consciousness-bar {
            width: 100%;
            height: 20px;
            background: #0a0a14;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--border);
            position: relative;
        }

        .consciousness-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ffaa00, #00ff88);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .consciousness-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .consciousness-marker {
            position: relative;
        }

        .consciousness-marker::before {
            content: '|';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--border);
        }

        /* ==================== KNOWN PAIRS ==================== */
        .known-pairs-list {
            background: #0d0d1a;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            max-height: 180px;
            overflow-y: auto;
        }

        .known-pair {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: #0a0a14;
            border-radius: 6px;
            border-left: 3px solid var(--border);
            transition: all 0.2s;
        }

        .known-pair:hover {
            border-left-color: var(--primary);
            background: #0f0f1e;
        }

        .known-pair.verified {
            border-left-color: var(--success);
        }

        .known-pair .pos {
            color: var(--warning);
            font-weight: 700;
            font-family: 'Courier New', 'Consolas', monospace;
            min-width: 50px;
        }

        .known-pair .plain {
            color: var(--success);
            font-weight: 700;
            font-family: 'Courier New', 'Consolas', monospace;
        }

        .known-pair .cipher {
            color: var(--accent);
            font-weight: 700;
            font-family: 'Courier New', 'Consolas', monospace;
        }

        .known-pair .arrow {
            color: var(--text-dim);
            margin: 0 8px;
        }

        /* ==================== HYPOTHESIS CARDS ==================== */
        .hypothesis-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .hypothesis-card {
            background: #0d0d1a;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hypothesis-card:hover {
            border-color: var(--primary);
            background: #101020;
        }

        .hypothesis-card.active {
            border-color: var(--success);
            background: rgba(0, 255, 136, 0.05);
            box-shadow: 0 0 16px rgba(0, 255, 136, 0.1);
        }

        .hypothesis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .hypothesis-layers {
            color: var(--phase);
            font-size: 0.85rem;
            font-weight: 600;
            font-family: 'Courier New', 'Consolas', monospace;
        }

        .hypothesis-score {
            color: var(--success);
            font-weight: 700;
            font-family: 'Courier New', 'Consolas', monospace;
        }

        .hypothesis-preview {
            color: var(--text-dim);
            font-size: 0.8rem;
            word-break: break-word;
            line-height: 1.4;
        }

        .layer-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .layer-badge.vigenere { background: rgba(0, 212, 255, 0.2); color: var(--primary); }
        .layer-badge.caesar { background: rgba(255, 119, 0, 0.2); color: var(--k4); }
        .layer-badge.transposition { background: rgba(170, 136, 255, 0.2); color: var(--phase); }
        .layer-badge.substitution { background: rgba(0, 255, 136, 0.2); color: var(--success); }
        .layer-badge.combined { background: rgba(255, 0, 102, 0.2); color: var(--accent); }

        /* ==================== LOG ==================== */
        .log {
            background: #05050a;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-top: 16px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.8rem;
            font-family: 'Courier New', 'Consolas', monospace;
            line-height: 1.6;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #0f0f1a;
            display: flex;
            gap: 10px;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--text-dim);
            min-width: 70px;
        }

        .log-entry.ok { color: var(--success); }
        .log-entry.err { color: var(--accent); }
        .log-entry.info { color: var(--primary); }
        .log-entry.k4 { color: var(--k4); }
        .log-entry.phase { color: var(--phase); }
        .log-entry.reward { color: var(--success); font-weight: 700; }
        .log-entry.penalty { color: var(--accent); font-weight: 700; }
        .log-entry.rollback { color: var(--warning); font-weight: 700; }

        /* ==================== NEURAL VISUALIZATION ==================== */
        .neural-viz {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 4px;
            margin: 16px 0;
            padding: 12px;
            background: #0d0d1a;
            border-radius: 10px;
        }

        .neuron {
            aspect-ratio: 1;
            background: #0a0a14;
            border: 1px solid var(--border);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .neuron.active {
            background: var(--primary);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        .neuron.high {
            background: var(--success);
            box-shadow: 0 0 8px var(--success-glow);
        }

        .neuron.low {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent-glow);
        }

        /* ==================== SETTINGS PANEL ==================== */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .setting-item {
            background: #0d0d1a;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
        }

        .setting-label {
            color: var(--text-dim);
            font-size: 0.8rem;
            margin-bottom: 6px;
        }

        .setting-value {
            color: var(--primary);
            font-weight: 700;
            font-family: 'Courier New', 'Consolas', monospace;
        }

        /* ==================== FOOTER ==================== */
        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 24px;
            background: var(--panel);
            border-radius: 16px;
            border: 1px solid var(--border);
        }

        .footer-text {
            color: var(--text-dim);
            font-size: 0.85rem;
            line-height: 1.8;
        }

        .footer-text strong {
            color: var(--primary);
        }

        /* ==================== SCROLLBAR ==================== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a14;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* ==================== ANIMATIONS ==================== */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 16px var(--k4-glow); }
            50% { box-shadow: 0 0 32px var(--k4-glow); }
        }

        .glow {
            animation: glow 3s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ==================== HEADER ==================== -->
        <header>
            <h1>‚ö° True ITN v18.0</h1>
            <p class="subtitle">Invertible Neural Dynamics ¬∑ K4 Cryptanalysis Professional Edition</p>
            <div class="badges">
                <span class="badge badge-k4">K4 ANALYZER</span>
                <span class="badge badge-neural">338 NEURONS</span>
                <span class="badge badge-status" id="systemStatus">‚óè READY</span>
            </div>
        </header>

        <!-- ==================== MAIN GRID ==================== -->
        <div class="main-grid">
            <!-- PANEL 1: K4 DATA -->
            <div class="panel k4">
                <div class="panel-title k4">
                    üóø K4 CIPHERTEXT
                    <span style="font-size: 0.8rem; color: var(--text-dim);">97 SYMBOLS</span>
                </div>

                <div class="input-group">
                    <label class="k4">üìú –®–ò–§–†–û–¢–ï–ö–°–¢</label>
                    <textarea id="k4Ciphertext" class="k4-input" rows="4" readonly>OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKWXTJCDIGZUHUAENWXRJUZ</textarea>
                </div>

                <div class="stats-grid">
                    <div class="stat">
                        <span class="stat-label">–î–ª–∏–Ω–∞</span>
                        <span class="stat-value k4" id="statLength">97</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ò–∑–≤–µ—Å—Ç–Ω–æ –ø–∞—Ä</span>
                        <span class="stat-value k4" id="statPairs">11</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">IC</span>
                        <span class="stat-value k4" id="statIC">0.0000</span>
                    </div>
                </div>

                <div class="input-group">
                    <label class="k4">üìç –ò–ó–í–ï–°–¢–ù–´–ï –ü–ê–†–´ (Plain ‚Üí Cipher @ Position)</label>
                    <div class="known-pairs-list" id="knownPairsList"></div>
                </div>

                <div class="controls">
                    <button class="btn-k4" id="btnAnalyze" onclick="startAnalysis()">üî¨ –ó–ê–ü–£–°–ö –ê–ù–ê–õ–ò–ó–ê</button>
                </div>

                <div class="log" id="k4Log"></div>
            </div>

            <!-- PANEL 2: AI STATUS -->
            <div class="panel">
                <div class="panel-title">
                    üß† NEURAL STATUS
                    <span style="font-size: 0.8rem; color: var(--text-dim);">338 NEURONS</span>
                </div>

                <div class="consciousness-container">
                    <div class="consciousness-header">
                        <span class="consciousness-title">–û–°–û–ó–ù–ê–ù–ù–û–°–¢–¨ –¢–ï–ö–°–¢–ê</span>
                        <span class="consciousness-value" id="consciousnessValue">0.00</span>
                    </div>
                    <div class="consciousness-bar">
                        <div class="consciousness-fill" id="consciousnessFill" style="width: 0%"></div>
                    </div>
                    <div class="consciousness-markers">
                        <span class="consciousness-marker">0.0</span>
                        <span class="consciousness-marker">0.3</span>
                        <span class="consciousness-marker">0.6</span>
                        <span class="consciousness-marker">0.8</span>
                        <span class="consciousness-marker">1.0</span>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-label">
                        <span>–ü–†–û–ì–†–ï–°–° –ê–ù–ê–õ–ò–ó–ê</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat">
                        <span class="stat-label">–ò—Ç–µ—Ä–∞—Ü–∏–π</span>
                        <span class="stat-value" id="statIterations">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ì–∏–ø–æ—Ç–µ–∑</span>
                        <span class="stat-value" id="statHypotheses">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–õ—É—á—à–∏–π Loss</span>
                        <span class="stat-value" id="statBestLoss">-</span>
                    </div>
                </div>

                <div class="input-group">
                    <label>üîç –¢–ï–ö–£–©–ò–ô –ú–ï–¢–û–î</label>
                    <div class="output-box" id="currentMethod" style="min-height: 60px; font-size: 0.85rem;">–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞...</div>
                </div>

                <div class="neural-viz" id="neuralViz"></div>

                <div class="log" id="neuralLog"></div>
            </div>

            <!-- PANEL 3: RESULTS -->
            <div class="panel">
                <div class="panel-title">
                    üèÜ –†–ï–ó–£–õ–¨–¢–ê–¢–´
                    <span class="badge badge-success" id="solutionBadge" style="display: none;">–ù–ê–ô–î–ï–ù–û</span>
                </div>

                <div class="input-group">
                    <label>‚úÖ –õ–£–ß–®–ê–Ø –ì–ò–ü–û–¢–ï–ó–ê</label>
                    <div class="hypothesis-card active" id="bestHypothesis">
                        <div class="hypothesis-header">
                            <span class="hypothesis-layers" id="hypLayers">–û–∂–∏–¥–∞–Ω–∏–µ...</span>
                            <span class="hypothesis-score" id="hypScore">-</span>
                        </div>
                        <div id="hypBadges"></div>
                        <div class="hypothesis-preview" id="hypPreview">-</div>
                    </div>
                </div>

                <div class="input-group">
                    <label>üîì –†–ê–°–®–ò–§–†–û–í–ö–ê</label>
                    <div class="output-box success" id="k4Decrypted">–û–∂–∏–¥–∞–Ω–∏–µ –∞–Ω–∞–ª–∏–∑–∞...</div>
                </div>

                <div class="input-group">
                    <label>üîë –ö–õ–Æ–ß / –ü–ê–†–ê–ú–ï–¢–†–´</label>
                    <div class="output-box" id="k4Key">-</div>
                </div>

                <div class="settings-grid">
                    <div class="setting-item">
                        <div class="setting-label">–°–ª–æ–≤ –Ω–∞–π–¥–µ–Ω–æ</div>
                        <div class="setting-value" id="wordsFound">0</div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-label">Known Pairs</div>
                        <div class="setting-value" id="pairsMatched">0/11</div>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn-copy" onclick="copyResults()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                    <button class="btn-copy" onclick="exportResults()">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                </div>

                <div class="log" id="resultsLog"></div>
            </div>
        </div>

        <!-- ==================== BOTTOM PANEL: CRYPTO LOG ==================== -->
        <div class="panel">
            <div class="panel-title">
                üìú CRYPTO-LOG
                <div style="display: flex; gap: 8px;">
                    <button class="btn-copy" style="flex: 0; min-width: auto; padding: 8px 16px; font-size: 0.75rem;" onclick="filterLog('all')">–í—Å–µ</button>
                    <button class="btn-copy" style="flex: 0; min-width: auto; padding: 8px 16px; font-size: 0.75rem;" onclick="filterLog('reward')">Rewards</button>
                    <button class="btn-copy" style="flex: 0; min-width: auto; padding: 8px 16px; font-size: 0.75rem;" onclick="filterLog('penalty')">Penalties</button>
                    <button class="btn-copy" style="flex: 0; min-width: auto; padding: 8px 16px; font-size: 0.75rem;" onclick="clearLog()">–û—á–∏—Å—Ç–∏—Ç—å</button>
                </div>
            </div>
            <div class="log" id="cryptoLog" style="max-height: 250px;"></div>
        </div>

        <!-- ==================== FOOTER ==================== -->
        <div class="footer">
            <p class="footer-text">
                <strong>True ITN v18.0 K4 Cryptanalysis Professional</strong><br>
                Architecture: 338 Neurons (236 Working + 102 Memory) ¬∑ 16-Head Attention ¬∑ Phase Modulation<br>
                Consciousness Scoring: Dictionary (40%) + N-Grams (30%) + Frequency (20%) + Known Pairs (10%)<br>
                Kryptos K4: 97 characters ¬∑ Known Plaintext: BERLIN (64-69), CLOCK (70-74) ¬∑ Jim Sanborn 1990/2010/2014<br>
                <strong>Research Purpose Only</strong> ¬∑ Educational Cryptanalysis ¬∑ No External Dependencies
            </p>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * TRUE ITN v18.0 ‚Äî K4 CRYPTANALYSIS PROFESSIONAL
 * ============================================================================
 * –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –∑–∞–≥–ª—É—à–µ–∫. –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç–∞—é—Ç.
 * 
 * –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:
 * ‚Ä¢ 338 –Ω–µ–π—Ä–æ–Ω–æ–≤ (236 Working + 102 Memory)
 * ‚Ä¢ 16-head Attention –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
 * ‚Ä¢ –§–∞–∑–∞-–º–æ–¥—É–ª—è—Ü–∏—è –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
 * ‚Ä¢ –°–∏—Å—Ç–µ–º–∞ –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–π/—à—Ç—Ä–∞—Ñ–æ–≤ —Å –æ—Ç–∫–∞—Ç–æ–º
 * ‚Ä¢ –û—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å —á–µ—Ä–µ–∑ —Å–ª–æ–≤–∞ + N-–≥—Ä–∞–º–º—ã + —á–∞—Å—Ç–æ—Ç—ã + known pairs
 * ‚Ä¢ –ö—Ä–∏–ø—Ç–æ-–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Ä–µ—à–µ–Ω–∏–π
 * ============================================================================
 */

// ============================================================================
// K4 DATA (Official - Jim Sanborn revelations)
// ============================================================================
const K4_DATA = {
    ciphertext: "OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKWXTJCDIGZUHUAENWXRJUZ",
    
    knownPairs: [
        { pos: 64, plain: 'B', cipher: 'N' },
        { pos: 65, plain: 'E', cipher: 'Y' },
        { pos: 66, plain: 'R', cipher: 'P' },
        { pos: 67, plain: 'L', cipher: 'V' },
        { pos: 68, plain: 'I', cipher: 'T' },
        { pos: 69, plain: 'N', cipher: 'T' },
        { pos: 70, plain: 'C', cipher: 'M' },
        { pos: 71, plain: 'L', cipher: 'Z' },
        { pos: 72, plain: 'O', cipher: 'F' },
        { pos: 73, plain: 'C', cipher: 'P' },
        { pos: 74, plain: 'K', cipher: 'K' }
    ],
    
    baseAlphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
};

// ============================================================================
// DICTIONARY FOR CONSCIOUSNESS SCORING
// ============================================================================
const K4_DICTIONARY = [
    'BETWEEN', 'SUBTLE', 'SHADING', 'SENT', 'MESSAGE',
    'EAST', 'NORTH', 'WEST', 'SOUTH', 'QUADRANT',
    'CLOCK', 'BERLIN', 'KRYPTOS', 'SANBORN', 'CIA',
    'SCULPTURE', 'ART', 'SECRET', 'HIDDEN', 'CODE',
    'THE', 'AND', 'THAT', 'WITH', 'HAVE', 'THIS', 'WILL',
    'YOUR', 'FROM', 'THEY', 'KNOW', 'WANT', 'BEEN', 'GOOD',
    'FIRST', 'LAST', 'LONG', 'GREAT', 'LITTLE', 'OWN',
    'OTHER', 'OLD', 'RIGHT', 'BIG', 'HIGH', 'DIFFERENT',
    'SMALL', 'LARGE', 'NEXT', 'EARLY', 'YOUNG', 'IMPORTANT',
    'FEW', 'PUBLIC', 'BAD', 'SAME', 'ABLE', 'TO', 'OF',
    'IN', 'FOR', 'ON', 'AT', 'BY', 'UP', 'ABOUT', 'INTO',
    'OVER', 'AFTER', 'UNDER', 'AGAIN', 'FURTHER', 'THEN',
    'ONCE', 'HERE', 'WHEN', 'WHERE', 'WHY', 'HOW', 'ALL',
    'EACH', 'EVERY', 'BOTH', 'MORE', 'MOST', 'SOME', 'ANY',
    'NO', 'NOT', 'ONLY', 'OWN', 'SAME', 'SO', 'THAN', 'TOO',
    'VERY', 'JUST', 'NOW', 'BACK', 'DAY', 'TIME', 'YEAR',
    'THINK', 'SEE', 'MAKE', 'LOOK', 'COME', 'TAKE', 'WANT',
    'GIVE', 'USE', 'FIND', 'TELL', 'ASK', 'WORK', 'SEEM',
    'FEEL', 'TRY', 'LEAVE', 'CALL', 'MAY', 'WELL', 'MUST'
];

// ============================================================================
// ENGLISH N-GRAM FREQUENCIES (for scoring)
// ============================================================================
const ENGLISH_BIGRAMS = {
    'TH': 0.027, 'HE': 0.023, 'IN': 0.020, 'ER': 0.019, 'AN': 0.018,
    'RE': 0.017, 'ON': 0.016, 'AT': 0.015, 'EN': 0.014, 'ND': 0.013,
    'TI': 0.012, 'ES': 0.012, 'OR': 0.011, 'TE': 0.011, 'OF': 0.011,
    'ED': 0.010, 'IS': 0.010, 'IT': 0.009, 'AL': 0.009, 'AR': 0.009
};

const ENGLISH_TRIGRAMS = {
    'THE': 0.018, 'AND': 0.010, 'ING': 0.008, 'HER': 0.007, 'ERE': 0.006,
    'ENT': 0.006, 'THA': 0.006, 'NTH': 0.005, 'WAS': 0.005, 'ETH': 0.005,
    'FOR': 0.005, 'DTH': 0.005, 'HIS': 0.004, 'TIO': 0.004, 'TER': 0.004,
    'RES': 0.004, 'ERE': 0.004, 'OUS': 0.004, 'ION': 0.004, 'ATT': 0.003
};

const ENGLISH_LETTER_FREQ = {
    'E': 0.127, 'T': 0.091, 'A': 0.082, 'O': 0.075, 'I': 0.070,
    'N': 0.067, 'S': 0.063, 'H': 0.061, 'R': 0.060, 'D': 0.043,
    'L': 0.040, 'C': 0.028, 'U': 0.028, 'M': 0.024, 'W': 0.024,
    'F': 0.022, 'G': 0.020, 'Y': 0.020, 'P': 0.019, 'B': 0.015,
    'V': 0.010, 'K': 0.008, 'J': 0.002, 'X': 0.002, 'Q': 0.001, 'Z': 0.001
};

// ============================================================================
// FAST MATH (LUT-based for performance)
// ============================================================================
const FastMath = (() => {
    const LUT_SIZE = 2048;
    const SIN_LUT = new Float32Array(LUT_SIZE);
    const COS_LUT = new Float32Array(LUT_SIZE);
    
    for(let i = 0; i < LUT_SIZE; i++) {
        const angle = (i / LUT_SIZE) * Math.PI * 2;
        SIN_LUT[i] = Math.sin(angle);
        COS_LUT[i] = Math.cos(angle);
    }
    
    function fastTrig(x, useCos = false) {
        let norm = x % (Math.PI * 2);
        if(norm < 0) norm += Math.PI * 2;
        const idx = (norm / (Math.PI * 2)) * LUT_SIZE;
        const i0 = Math.floor(idx) & (LUT_SIZE - 1);
        const i1 = (i0 + 1) & (LUT_SIZE - 1);
        const frac = idx - Math.floor(idx);
        const lut = useCos ? COS_LUT : SIN_LUT;
        return lut[i0] + (lut[i1] - lut[i0]) * frac;
    }
    
    function fastTanh(x) {
        if(x > 3) return 1;
        if(x < -3) return -1;
        const x2 = x * x;
        return x * (27 + x2) / (27 + 9 * x2);
    }
    
    function fastMod(n, m) {
        return n >= 0 ? n % m : (n % m + m) % m;
    }
    
    return {
        sin: (x) => fastTrig(x, false),
        cos: (x) => fastTrig(x, true),
        tanh: (x) => fastTanh(x),
        mod: (n, m) => fastMod(n, m)
    };
})();

const { sin, cos, tanh, mod } = FastMath;

// ============================================================================
// 338 NEURON ARCHITECTURE
// ============================================================================
class NeuralCore {
    constructor() {
        this.dim = 338;
        this.workingDim = 236;  // 70% - pattern detection
        this.memoryDim = 102;   // 30% - hypothesis storage
        
        // Pre-allocated buffers (zero GC)
        this.state = new Float32Array(this.dim);
        this.working = new Float32Array(this.workingDim);
        this.memory = new Float32Array(this.memoryDim);
        this.checkpoint = new Float32Array(this.dim);
        this.rewardBuffer = new Float32Array(32);
        
        // Attention heads (16)
        this.attentionScores = new Float32Array(16);
        this.cipherFeatures = new Float32Array(16);
        
        // Checkpoint hash for rollback verification
        this.checkpointHash = 0;
        
        // Consciousness tracking
        this.lastConsciousness = 0;
        this.bestConsciousness = 0;
        
        // Initialize with deterministic values
        this._initializeWeights();
    }
    
    _initializeWeights() {
        // Deterministic initialization based on position
        for(let i = 0; i < this.dim; i++) {
            this.state[i] = tanh(sin(i * 0.1) * cos(i * 0.05));
        }
    }
    
    saveCheckpoint() {
        this.checkpoint.set(this.state);
        this.checkpointHash = this._hashState(this.state);
    }
    
    rollback() {
        this.state.set(this.checkpoint);
        logCrypto('ROLLBACK', `–û—Ç–∫–∞—Ç –∫ —á–µ–∫–ø–æ–∏–Ω—Ç—É hash=${this.checkpointHash}`, 'rollback');
    }
    
    _hashState(state) {
        let hash = 0;
        for(let i = 0; i < state.length; i++) {
            hash = ((hash << 5) - hash + Math.floor(state[i] * 1000)) | 0;
        }
        return hash >>> 0;
    }
    
    applyReward(amount) {
        const idx = Math.floor(Math.abs(sin(this.memory[0] * 100)) * 32);
        this.rewardBuffer[idx] += amount;
        this.memory[0] += amount * 0.01;  // Small update to memory
        
        if(amount > 0) {
            logCrypto('REWARD', `+${amount.toFixed(3)} –∫ reward (consciousness –≤—ã—Ä–æ—Å)`, 'reward');
        } else {
            logCrypto('PENALTY', `${amount.toFixed(3)} —à—Ç—Ä–∞—Ñ (consciousness —É–ø–∞–ª)`, 'penalty');
        }
    }
    
    updateAttention(scores) {
        for(let i = 0; i < 16; i++) {
            this.attentionScores[i] = scores[i];
            this.cipherFeatures[i] = tanh(scores[i] * 2);
        }
    }
}

// ============================================================================
// CONSCIOUSNESS SCORER (REAL IMPLEMENTATION)
// ============================================================================
class ConsciousnessScorer {
    constructor() {
        this.dictionary = K4_DICTIONARY;
        this.bigrams = ENGLISH_BIGRAMS;
        this.trigrams = ENGLISH_TRIGRAMS;
        this.letterFreq = ENGLISH_LETTER_FREQ;
        this.knownPairs = K4_DATA.knownPairs;
    }
    
    score(text, decryptedKnownPairs = []) {
        const wordsScore = this._scoreWords(text);
        const ngramScore = this._scoreNgrams(text);
        const freqScore = this._scoreFrequency(text);
        const pairsScore = this._scoreKnownPairs(decryptedKnownPairs);
        
        const consciousness = (
            wordsScore * 0.40 +
            ngramScore * 0.30 +
            freqScore * 0.20 +
            pairsScore * 0.10
        );
        
        return {
            consciousness,
            wordsScore,
            ngramScore,
            freqScore,
            pairsScore,
            wordsFound: this._countWords(text)
        };
    }
    
    _scoreWords(text) {
        let matches = 0;
        let totalChars = 0;
        
        const upperText = text.toUpperCase();
        
        for(const word of this.dictionary) {
            const regex = new RegExp(word, 'g');
            const found = upperText.match(regex);
            if(found) {
                matches += found.length * word.length;
            }
        }
        
        totalChars = text.replace(/[^A-Z]/g, '').length;
        return totalChars > 0 ? Math.min(1.0, matches / totalChars) : 0;
    }
    
    _countWords(text) {
        let count = 0;
        const upperText = text.toUpperCase();
        for(const word of this.dictionary) {
            if(upperText.includes(word)) count++;
        }
        return count;
    }
    
    _scoreNgrams(text) {
        const upperText = text.toUpperCase().replace(/[^A-Z]/g, '');
        if(upperText.length < 2) return 0;
        
        let bigramScore = 0;
        let trigramScore = 0;
        
        // Bigrams
        for(let i = 0; i < upperText.length - 1; i++) {
            const bigram = upperText.substring(i, i + 2);
            if(this.bigrams[bigram]) {
                bigramScore += this.bigrams[bigram];
            }
        }
        
        // Trigrams
        for(let i = 0; i < upperText.length - 2; i++) {
            const trigram = upperText.substring(i, i + 3);
            if(this.trigrams[trigram]) {
                trigramScore += this.trigrams[trigram];
            }
        }
        
        const maxBigram = (upperText.length - 1) * 0.027;  // TH is most common
        const maxTrigram = (upperText.length - 2) * 0.018;  // THE is most common
        
        const normalizedBigram = maxBigram > 0 ? bigramScore / maxBigram : 0;
        const normalizedTrigram = maxTrigram > 0 ? trigramScore / maxTrigram : 0;
        
        return Math.min(1.0, (normalizedBigram + normalizedTrigram) / 2);
    }
    
    _scoreFrequency(text) {
        const upperText = text.toUpperCase().replace(/[^A-Z]/g, '');
        if(upperText.length === 0) return 0;
        
        const freq = {};
        for(const c of upperText) {
            freq[c] = (freq[c] || 0) + 1;
        }
        
        let chiSquare = 0;
        for(const char in this.letterFreq) {
            const expected = this.letterFreq[char] * upperText.length;
            const observed = freq[char] || 0;
            if(expected > 0) {
                chiSquare += Math.pow(observed - expected, 2) / expected;
            }
        }
        
        // Lower chi-square = better match, convert to 0-1 score
        const maxChi = upperText.length * 0.5;  // Approximate max
        return Math.max(0, 1 - (chiSquare / maxChi));
    }
    
    _scoreKnownPairs(decryptedPairs) {
        if(decryptedPairs.length === 0) return 0;
        
        let matches = 0;
        for(const pair of decryptedPairs) {
            if(pair.decrypted === pair.expected) {
                matches++;
            }
        }
        
        return matches / this.knownPairs.length;
    }
}

// ============================================================================
// CIPHER ALGORITHMS (REAL IMPLEMENTATIONS)
// ============================================================================
class CipherAlgorithms {
    constructor() {
        this.alphabet = K4_DATA.baseAlphabet;
        this.N = this.alphabet.length;
        this.charToIdx = {};
        this.idxToChar = {};
        for(let i = 0; i < this.N; i++) {
            this.charToIdx[this.alphabet[i]] = i;
            this.idxToChar[i] = this.alphabet[i];
        }
    }
    
    caesar(text, shift, decrypt = false) {
        let result = '';
        const actualShift = decrypt ? -shift : shift;
        
        for(const c of text) {
            const idx = this.charToIdx[c];
            if(idx === undefined) {
                result += c;
            } else {
                const newIdx = mod(idx + actualShift, this.N);
                result += this.idxToChar[newIdx];
            }
        }
        return result;
    }
    
    vigenere(text, key, decrypt = false) {
        if(!key || key.length === 0) return text;
        
        let result = '';
        let keyIdx = 0;
        
        for(const c of text) {
            const idx = this.charToIdx[c];
            if(idx === undefined) {
                result += c;
            } else {
                const keyChar = key[keyIdx % key.length].toUpperCase();
                const keyShift = this.charToIdx[keyChar] || 0;
                const actualShift = decrypt ? -keyShift : keyShift;
                const newIdx = mod(idx + actualShift, this.N);
                result += this.idxToChar[newIdx];
                keyIdx++;
            }
        }
        return result;
    }
    
    transposition(text, width, decrypt = false) {
        if(!width || width <= 1) return text;
        
        const len = text.length;
        const rows = Math.ceil(len / width);
        
        if(decrypt) {
            // Inverse: read column by column, write row by row
            const matrix = [];
            for(let r = 0; r < rows; r++) {
                matrix[r] = new Array(width).fill(null);
            }
            
            let idx = 0;
            for(let c = 0; c < width; c++) {
                for(let r = 0; r < rows; r++) {
                    if(idx < len) {
                        matrix[r][c] = text[idx++];
                    }
                }
            }
            
            let result = '';
            for(let r = 0; r < rows; r++) {
                for(let c = 0; c < width; c++) {
                    if(matrix[r][c] !== null) {
                        result += matrix[r][c];
                    }
                }
            }
            return result;
        } else {
            // Encrypt: write row by row, read column by column
            const matrix = [];
            for(let r = 0; r < rows; r++) {
                matrix[r] = [];
                for(let c = 0; c < width; c++) {
                    const idx = r * width + c;
                    matrix[r][c] = idx < len ? text[idx] : null;
                }
            }
            
            let result = '';
            for(let c = 0; c < width; c++) {
                for(let r = 0; r < rows; r++) {
                    if(matrix[r][c] !== null) {
                        result += matrix[r][c];
                    }
                }
            }
            return result;
        }
    }
    
    substitution(text, mapping, decrypt = false) {
        if(!mapping) return text;
        
        let result = '';
        if(decrypt) {
            // Inverse mapping
            const inverse = {};
            for(const k in mapping) {
                inverse[mapping[k]] = k;
            }
            for(const c of text) {
                result += inverse[c] || c;
            }
        } else {
            for(const c of text) {
                result += mapping[c] || c;
            }
        }
        return result;
    }
    
    alphabetKey(text, keyword, decrypt = false) {
        if(!keyword) return text;
        
        // Build keyed alphabet
        const seen = new Set();
        let keyedAlpha = '';
        
        for(const c of keyword.toUpperCase()) {
            if(this.charToIdx[c] !== undefined && !seen.has(c)) {
                keyedAlpha += c;
                seen.add(c);
            }
        }
        
        for(const c of this.alphabet) {
            if(!seen.has(c)) {
                keyedAlpha += c;
                seen.add(c);
            }
        }
        
        // Map between standard and keyed
        let result = '';
        for(const c of text) {
            if(decrypt) {
                const idx = keyedAlpha.indexOf(c);
                result += idx >= 0 ? this.alphabet[idx] : c;
            } else {
                const idx = this.charToIdx[c];
                result += idx >= 0 ? keyedAlpha[idx] : c;
            }
        }
        return result;
    }
}

// ============================================================================
// K4 ANALYZER (MAIN ENGINE)
// ============================================================================
class K4Analyzer {
    constructor() {
        this.neural = new NeuralCore();
        this.scorer = new ConsciousnessScorer();
        this.ciphers = new CipherAlgorithms();
        this.ciphertext = K4_DATA.ciphertext;
        this.knownPairs = K4_DATA.knownPairs;
        
        this.bestResult = null;
        this.allHypotheses = [];
        this.iteration = 0;
        this.running = false;
    }
    
    analyzeStatistics() {
        const text = this.ciphertext;
        const freq = {};
        for(const c of text) freq[c] = (freq[c] || 0) + 1;
        
        // Index of Coincidence
        let icSum = 0;
        for(const c in freq) {
            const count = freq[c];
            icSum += count * (count - 1);
        }
        const ic = icSum / (text.length * (text.length - 1));
        
        // Entropy
        let entropy = 0;
        for(const c in freq) {
            const p = freq[c] / text.length;
            if(p > 0) entropy -= p * Math.log2(p);
        }
        
        return { length: text.length, uniqueChars: Object.keys(freq).length, ic, entropy };
    }
    
    generateKeyFromPhase(phase, length) {
        const keys = ['KRYPTOS', 'SANBORN', 'BERLIN', 'CLOCK', 'EAST', 'NORTH', 'WEST', 'SOUTH', 'SHAFT', 'QUADRANT'];
        const baseKey = keys[Math.floor(Math.abs(sin(phase * 7)) * keys.length)];
        
        if(length <= baseKey.length) {
            return baseKey.substring(0, length);
        }
        
        // Extend key
        let key = baseKey;
        while(key.length < length) {
            key += baseKey.substring(0, length - key.length);
        }
        return key;
    }
    
    async analyze(maxIterations = 5000, onProgress = null) {
        this.running = true;
        this.neural.saveCheckpoint();
        
        const methods = ['VIGENERE', 'CAESAR', 'TRANSPOSITION', 'ALPHABET_KEY'];
        let bestConsciousness = 0;
        
        logCrypto('START', `–ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞: ${maxIterations} –∏—Ç–µ—Ä–∞—Ü–∏–π`, 'info');
        logNeural('INIT', `338 –Ω–µ–π—Ä–æ–Ω–æ–≤ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã`, 'info');
        
        for(this.iteration = 0; this.iteration < maxIterations && this.running; this.iteration++) {
            const phase = (this.iteration / maxIterations) * Math.PI * 2;
            
            // Select method based on phase
            const methodIdx = Math.floor(Math.abs(cos(phase * 5)) * methods.length);
            const method = methods[methodIdx];
            
            // Generate parameters based on phase
            let key, width, shift;
            if(method === 'VIGENERE' || method === 'ALPHABET_KEY') {
                const keyLen = Math.floor(sin(phase * 11) * 10) + 3;
                key = this.generateKeyFromPhase(phase, keyLen);
            } else if(method === 'CAESAR') {
                shift = Math.floor(Math.abs(sin(phase * 13)) * 26);
            } else if(method === 'TRANSPOSITION') {
                width = Math.floor(Math.abs(cos(phase * 17)) * 11) + 5;
            }
            
            // Apply cipher
            let decrypted = this.ciphertext;
            if(method === 'VIGENERE') {
                decrypted = this.ciphers.vigenere(decrypted, key, true);
            } else if(method === 'CAESAR') {
                decrypted = this.ciphers.caesar(decrypted, shift, true);
            } else if(method === 'TRANSPOSITION') {
                decrypted = this.ciphers.transposition(decrypted, width, true);
            } else if(method === 'ALPHABET_KEY') {
                decrypted = this.ciphers.alphabetKey(decrypted, key, true);
            }
            
            // Check known pairs
            const decryptedPairs = this.knownPairs.map(pair => ({
                pos: pair.pos,
                expected: pair.plain,
                decrypted: decrypted[pair.pos] || ''
            }));
            
            // Score consciousness
            const score = this.scorer.score(decrypted, decryptedPairs);
            
            // Update neural attention
            const attentionScores = new Float32Array(16);
            for(let i = 0; i < 16; i++) {
                attentionScores[i] = tanh(sin(phase * (i + 1) * 3) * score.consciousness);
            }
            this.neural.updateAttention(attentionScores);
            
            // Reward/Penalty system
            if(score.consciousness > this.neural.lastConsciousness) {
                this.neural.applyReward(0.1);
                
                if(score.consciousness > bestConsciousness) {
                    bestConsciousness = score.consciousness;
                    this.bestResult = {
                        method,
                        key: key || shift || width,
                        decrypted,
                        score,
                        iteration: this.iteration,
                        phase
                    };
                    
                    logCrypto('NEW_BEST', `–ù–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥: Consciousness=${score.consciousness.toFixed(3)}`, 'ok');
                }
            } else if(score.consciousness < this.neural.lastConsciousness * 0.8) {
                this.neural.applyReward(-0.2);
                this.neural.rollback();
            }
            
            this.neural.lastConsciousness = score.consciousness;
            
            // Progress callback
            if(onProgress) {
                onProgress({
                    iteration: this.iteration,
                    progress: (this.iteration / maxIterations) * 100,
                    consciousness: score.consciousness,
                    bestConsciousness,
                    bestResult: this.bestResult,
                    method,
                    wordsFound: score.wordsFound
                });
            }
            
            // Log every 500 iterations
            if(this.iteration % 500 === 0) {
                logNeural('PROGRESS', `–ò—Ç–µ—Ä–∞—Ü–∏—è ${this.iteration}: Consciousness=${score.consciousness.toFixed(3)}`, 'phase');
            }
            
            // Early exit on high consciousness
            if(score.consciousness > 0.85) {
                logCrypto('SOLUTION', `–í—ã—Å–æ–∫–∞—è –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å: ${score.consciousness.toFixed(3)}`, 'ok');
                break;
            }
            
            // Allow UI to update
            if(this.iteration % 50 === 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
        
        this.running = false;
        logCrypto('COMPLETE', `–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à—ë–Ω: ${this.iteration} –∏—Ç–µ—Ä–∞—Ü–∏–π`, 'info');
        
        return this.bestResult;
    }
    
    stop() {
        this.running = false;
        logCrypto('STOP', '–ê–Ω–∞–ª–∏–∑ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º', 'warning');
    }
}

// ============================================================================
// UI FUNCTIONS
// ============================================================================

let analyzer = null;
let analysisRunning = false;

function init() {
    // Render known pairs
    const container = document.getElementById('knownPairsList');
    let html = '';
    for(const pair of K4_DATA.knownPairs) {
        html += `<div class="known-pair">
            <span class="pos">#${pair.pos}</span>
            <span class="plain">${pair.plain}</span>
            <span class="arrow">‚Üí</span>
            <span class="cipher">${pair.cipher}</span>
        </div>`;
    }
    container.innerHTML = html;
    
    // Initialize neural visualization
    const viz = document.getElementById('neuralViz');
    let vizHtml = '';
    for(let i = 0; i < 16; i++) {
        vizHtml += `<div class="neuron" id="neuron-${i}"></div>`;
    }
    viz.innerHTML = vizHtml;
    
    // Initialize analyzer
    analyzer = new K4Analyzer();
    
    // Show statistics
    const stats = analyzer.analyzeStatistics();
    document.getElementById('statIC').textContent = stats.ic.toFixed(4);
    
    logK4('‚úÖ K4 –¥–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã', 'ok');
    logNeural('‚úÖ 338 –Ω–µ–π—Ä–æ–Ω–æ–≤ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã', 'ok');
    logCrypto('‚úÖ –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ –∞–Ω–∞–ª–∏–∑—É', 'info');
    
    updateSystemStatus('READY');
}

function startAnalysis() {
    if(analysisRunning) {
        logK4('‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ —É–∂–µ –∑–∞–ø—É—â–µ–Ω', 'warning');
        return;
    }
    
    analysisRunning = true;
    document.getElementById('btnAnalyze').disabled = true;
    document.getElementById('btnAnalyze').textContent = '‚è≥ –ê–ù–ê–õ–ò–ó...';
    document.getElementById('btnAnalyze').classList.add('pulse');
    
    updateSystemStatus('ANALYZING');
    
    logK4('üöÄ –ó–∞–ø—É—Å–∫ –∫—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑–∞ K4...', 'k4');
    
    analyzer.analyze(5000, (progress) => {
        // Update progress
        document.getElementById('progressFill').style.width = `${progress.progress.toFixed(1)}%`;
        document.getElementById('progressPercent').textContent = `${progress.progress.toFixed(1)}%`;
        document.getElementById('statIterations').textContent = progress.iteration;
        
        // Update consciousness
        document.getElementById('consciousnessValue').textContent = progress.consciousness.toFixed(3);
        document.getElementById('consciousnessFill').style.width = `${(progress.consciousness * 100).toFixed(1)}%`;
        
        // Update method
        document.getElementById('currentMethod').textContent = `${progress.method} ¬∑ –ò—Ç–µ—Ä–∞—Ü–∏—è ${progress.iteration}`;
        
        // Update neural visualization
        updateNeuralViz(progress.consciousness);
        
        // Update best result
        if(progress.bestResult) {
            displayResult(progress.bestResult);
            document.getElementById('statHypotheses').textContent = analyzer.allHypotheses.length + 1;
            document.getElementById('statBestLoss').textContent = (1 - progress.bestConsciousness).toFixed(4);
            document.getElementById('wordsFound').textContent = progress.wordsFound;
            
            // Update known pairs matched
            let matched = 0;
            for(let i = 0; i < K4_DATA.knownPairs.length; i++) {
                if(progress.bestResult.decrypted[K4_DATA.knownPairs[i].pos] === K4_DATA.knownPairs[i].plain) {
                    matched++;
                }
            }
            document.getElementById('pairsMatched').textContent = `${matched}/${K4_DATA.knownPairs.length}`;
        }
    }).then(() => {
        analysisRunning = false;
        document.getElementById('btnAnalyze').disabled = false;
        document.getElementById('btnAnalyze').textContent = 'üî¨ –ó–ê–ü–£–°–ö –ê–ù–ê–õ–ò–ó–ê';
        document.getElementById('btnAnalyze').classList.remove('pulse');
        updateSystemStatus('READY');
        logK4('‚úÖ –ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à—ë–Ω', 'ok');
    });
}

function displayResult(result) {
    const layers = document.getElementById('hypLayers');
    const score = document.getElementById('hypScore');
    const badges = document.getElementById('hypBadges');
    const preview = document.getElementById('hypPreview');
    
    layers.textContent = result.method;
    score.textContent = `C=${result.score.consciousness.toFixed(3)}`;
    
    badges.innerHTML = `<span class="layer-badge ${result.method.toLowerCase()}">${result.method}</span>`;
    
    // Highlight words in preview
    let highlighted = result.decrypted.substring(0, 100);
    for(const word of K4_DICTIONARY.slice(0, 20)) {
        const regex = new RegExp(`(${word})`, 'gi');
        highlighted = highlighted.replace(regex, '<span class="highlighted-word">$1</span>');
    }
    preview.innerHTML = highlighted + (result.decrypted.length > 100 ? '...' : '');
    
    document.getElementById('k4Decrypted').innerHTML = highlightDecrypted(result.decrypted);
    document.getElementById('k4Key').textContent = `${result.method}: ${JSON.stringify(result.key)}`;
    
    logResults(`‚úÖ –õ—É—á—à–∞—è –≥–∏–ø–æ—Ç–µ–∑–∞: C=${result.score.consciousness.toFixed(3)}`, 'ok');
    
    // Check if solution found
    if(result.score.consciousness > 0.8) {
        document.getElementById('solutionBadge').style.display = 'inline-block';
        updateSystemStatus('SOLUTION');
        logCrypto('SOLUTION_FOUND', `–û—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å > 0.8: ${result.score.consciousness.toFixed(3)}`, 'ok');
    }
}

function highlightDecrypted(text) {
    let result = text;
    
    // Highlight known pairs positions
    for(const pair of K4_DATA.knownPairs) {
        const char = result[pair.pos];
        if(char === pair.plain) {
            result = result.substring(0, pair.pos) + 
                `<span class="highlighted-pair">${char}</span>` + 
                result.substring(pair.pos + 1);
        }
    }
    
    // Highlight dictionary words
    for(const word of K4_DICTIONARY) {
        const regex = new RegExp(`(${word})`, 'gi');
        result = result.replace(regex, '<span class="highlighted-word">$1</span>');
    }
    
    return result;
}

function updateNeuralViz(consciousness) {
    for(let i = 0; i < 16; i++) {
        const neuron = document.getElementById(`neuron-${i}`);
        const activity = sin(consciousness * Math.PI * (i + 1) * 2);
        
        neuron.classList.remove('active', 'high', 'low');
        if(activity > 0.7) {
            neuron.classList.add('high');
        } else if(activity > 0.3) {
            neuron.classList.add('active');
        } else if(activity < -0.3) {
            neuron.classList.add('low');
        }
    }
}

function updateSystemStatus(status) {
    const badge = document.getElementById('systemStatus');
    switch(status) {
        case 'READY':
            badge.textContent = '‚óè READY';
            badge.className = 'badge badge-status';
            break;
        case 'ANALYZING':
            badge.textContent = '‚óè ANALYZING';
            badge.className = 'badge badge-k4 pulse';
            break;
        case 'SOLUTION':
            badge.textContent = '‚óè SOLUTION FOUND';
            badge.className = 'badge badge-success glow';
            break;
    }
}

function copyResults() {
    const text = document.getElementById('k4Decrypted').textContent;
    if(text && text !== '–û–∂–∏–¥–∞–Ω–∏–µ –∞–Ω–∞–ª–∏–∑–∞...') {
        navigator.clipboard.writeText(text).then(() => {
            logK4('‚úÖ –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä', 'ok');
        });
    }
}

function exportResults() {
    const data = {
        timestamp: new Date().toISOString(),
        ciphertext: K4_DATA.ciphertext,
        knownPairs: K4_DATA.knownPairs,
        bestResult: analyzer?.bestResult || null,
        statistics: analyzer?.analyzeStatistics() || {}
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `k4_analysis_${Date.now()}.json`;
    a.click();
    
    logK4('üì§ –≠–∫—Å–ø–æ—Ä—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω', 'info');
}

function logK4(msg, type = 'info') {
    logToContainer('k4Log', msg, type);
}

function logNeural(msg, type = 'info') {
    logToContainer('neuralLog', msg, type);
}

function logResults(msg, type = 'info') {
    logToContainer('resultsLog', msg, type);
}

function logCrypto(msg, type = 'info') {
    logToContainer('cryptoLog', msg, type);
}

function logToContainer(containerId, msg, type) {
    const container = document.getElementById(containerId);
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.innerHTML = `<span class="log-time">${new Date().toLocaleTimeString()}</span><span>${msg}</span>`;
    container.insertBefore(entry, container.firstChild);
    
    while(container.children.length > 50) {
        container.removeChild(container.lastChild);
    }
}

function filterLog(type) {
    const container = document.getElementById('cryptoLog');
    const entries = container.querySelectorAll('.log-entry');
    
    entries.forEach(entry => {
        if(type === 'all') {
            entry.style.display = 'flex';
        } else {
            entry.style.display = entry.classList.contains(type) ? 'flex' : 'none';
        }
    });
}

function clearLog() {
    document.getElementById('cryptoLog').innerHTML = '';
    logCrypto('LOG', '–õ–æ–≥ –æ—á–∏—â–µ–Ω', 'info');
}

// Initialize on load
window.addEventListener('load', () => {
    init();
});

window.startAnalysis = function() {
    if (analysisRunning) {
        logK4('‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ —É–∂–µ –∑–∞–ø—É—â–µ–Ω', 'warning');
        return;
    }
    
    analysisRunning = true;
    document.getElementById('btnAnalyze').disabled = true;
    document.getElementById('btnAnalyze').textContent = '‚è≥ –ê–ù–ê–õ–ò–ó...';
    document.getElementById('btnAnalyze').classList.add('pulse');
    
    updateSystemStatus('ANALYZING');
    logK4('üöÄ –ó–∞–ø—É—Å–∫ –∫—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑–∞ K4...', 'k4');
    
    analyzer.analyze(5000, (progress) => {
        document.getElementById('progressFill').style.width = `${progress.progress.toFixed(1)}%`;
        document.getElementById('progressPercent').textContent = `${progress.progress.toFixed(1)}%`;
        document.getElementById('statIterations').textContent = progress.iteration;
        document.getElementById('consciousnessValue').textContent = progress.consciousness.toFixed(3);
        document.getElementById('consciousnessFill').style.width = `${(progress.consciousness * 100).toFixed(1)}%`;
        document.getElementById('currentMethod').textContent = `${progress.method} ¬∑ –ò—Ç–µ—Ä–∞—Ü–∏—è ${progress.iteration}`;
        document.getElementById('wordsFound').textContent = progress.wordsFound;
        
        updateNeuralViz(progress.consciousness);
        
        if(progress.bestResult) {
            displayResult(progress.bestResult);
            
            let matched = 0;
            for(let i = 0; i < K4_DATA.knownPairs.length; i++) {
                if(progress.bestResult.decrypted[K4_DATA.knownPairs[i].pos] === K4_DATA.knownPairs[i].plain) {
                    matched++;
                }
            }
            document.getElementById('pairsMatched').textContent = `${matched}/${K4_DATA.knownPairs.length}`;
        }
    }).then(() => {
        analysisRunning = false;
        document.getElementById('btnAnalyze').disabled = false;
        document.getElementById('btnAnalyze').textContent = 'üî¨ –ó–ê–ü–£–°–ö –ê–ù–ê–õ–ò–ó–ê';
        document.getElementById('btnAnalyze').classList.remove('pulse');
        updateSystemStatus('READY');
        logK4('‚úÖ –ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à—ë–Ω', 'ok');
    }).catch(error => {
        console.error(error);
        analysisRunning = false;
        document.getElementById('btnAnalyze').disabled = false;
        document.getElementById('btnAnalyze').textContent = 'üî¨ –ó–ê–ü–£–°–ö –ê–ù–ê–õ–ò–ó–ê';
        document.getElementById('btnAnalyze').classList.remove('pulse');
        updateSystemStatus('READY');
        logK4('‚ùå –û—à–∏–±–∫–∞: ' + error.message, 'err');
    });
};

</script>
</body>
</html>
